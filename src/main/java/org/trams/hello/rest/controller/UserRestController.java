/*
 * Created on 7 thg 12 2016 ( Time 10:36:17 )
 * Generated by Telosys Tools Generator ( version 2.1.1 )
 */
package org.trams.hello.rest.controller;

import java.lang.reflect.Type;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.data.domain.Page;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.trams.hello.bean.Answer;
import org.trams.hello.bean.CounselingSession;
import org.trams.hello.bean.Counselor;
import org.trams.hello.bean.CounselorScheduleSetting;
import org.trams.hello.bean.Message;
import org.trams.hello.bean.Notice;
import org.trams.hello.bean.PasswordHistory;
import org.trams.hello.bean.PaymentHistory;
import org.trams.hello.bean.Question;
import org.trams.hello.bean.RequestUserPsychological;
import org.trams.hello.bean.SelfDiagnosisAnswer;
import org.trams.hello.bean.SelfDiagnosisResults;
import org.trams.hello.bean.ShareHistory;
import org.trams.hello.bean.TestResult;
import org.trams.hello.bean.User;
import org.trams.hello.bean.UserItem;
import org.trams.hello.bean.UserNotice;
import org.trams.hello.bean.UserNotification;
import org.trams.hello.bean.UserQuestionaire;
import org.trams.hello.bean.UserReceiveMessage;
import org.trams.hello.bean.Voucher;
import org.trams.hello.bean.VoucherUser;
import org.trams.hello.bean.api.Announcement;
import org.trams.hello.bean.api.CompletedCounselingListByYear;
import org.trams.hello.bean.api.HelloCoinSummary;
import org.trams.hello.bean.api.HelloVoucherSummary;
import org.trams.hello.bean.api.InboxMessage;
import org.trams.hello.bean.api.LatestSelfDiagnosisResult;
import org.trams.hello.bean.api.MyHello;
import org.trams.hello.bean.api.MyReservation;
import org.trams.hello.bean.api.PsychologicalTest;
import org.trams.hello.bean.api.PsychologicalTestResult;
import org.trams.hello.bean.api.PsychologicalTestSetting;
import org.trams.hello.bean.api.QAMindCheck;
import org.trams.hello.bean.api.QAMindcheckUser;
import org.trams.hello.bean.api.QASatisfactionEvaluation;
import org.trams.hello.bean.api.QASelfDiagnosis;
import org.trams.hello.bean.api.ReservationDate;
import org.trams.hello.bean.api.ReservationTimeSelect;
import org.trams.hello.bean.api.ReservedAndCounselingType;
import org.trams.hello.bean.api.SelfDiagnosis;
import org.trams.hello.bean.api.UserPsychologicalFileApi;
import org.trams.hello.bean.jpa.CounselingSessionEntity;
import org.trams.hello.bean.jpa.CounselorEntity;
import org.trams.hello.bean.jpa.PasswordHistoryEntity;
import org.trams.hello.bean.jpa.PaymentHistoryEntity;
import org.trams.hello.bean.jpa.UserPsychologicalEntity;
import org.trams.hello.bean.jpa.UserReceiveMessageEntity;
import org.trams.hello.bean.web.counselor.SuggestionCounselor;
import org.trams.hello.business.event.CounselingSessionScheduleAddedEvent;
import org.trams.hello.business.event.CounselorMessageAddedEvent;
import org.trams.hello.business.event.PsyTestPaymentAddedEvent;
import org.trams.hello.business.service.AnswerService;
import org.trams.hello.business.service.CounselingSessionService;
import org.trams.hello.business.service.CounselorScheduleSettingService;
import org.trams.hello.business.service.CounselorService;
import org.trams.hello.business.service.MessageService;
import org.trams.hello.business.service.NoticeService;
import org.trams.hello.business.service.NotificationService;
import org.trams.hello.business.service.PasswordHistoryService;
import org.trams.hello.business.service.PaymentHistoryService;
import org.trams.hello.business.service.QuestionService;
import org.trams.hello.business.service.RequestUserPsychologicalService;
import org.trams.hello.business.service.SelfDiagnosisAnswerService;
import org.trams.hello.business.service.SelfDiagnosisResultsService;
import org.trams.hello.business.service.ShareHistoryService;
import org.trams.hello.business.service.TestResultService;
import org.trams.hello.business.service.UserNoticeService;
import org.trams.hello.business.service.UserNotificationService;
import org.trams.hello.business.service.UserPsychologicalFileService;
import org.trams.hello.business.service.UserPsychologicalService;
import org.trams.hello.business.service.UserQuestionaireService;
import org.trams.hello.business.service.UserReceiveMessageService;
import org.trams.hello.business.service.UserService;
import org.trams.hello.business.service.VoucherService;
import org.trams.hello.business.service.VoucherUserService;
import org.trams.hello.common.mail.Mail;
import org.trams.hello.common.mail.Mail.EmailTemplate;
import org.trams.hello.rest.common.AbstractRestController;
import org.trams.hello.rest.common.AuthorizationToken;
import org.trams.hello.rest.common.Utils;
import org.trams.hello.web.common.ApplicationDefine;
import org.trams.hello.web.common.Login;
import org.trams.hello.web.common.utils.DataUtils;
import org.trams.hello.web.common.utils.EncryptionUtils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;

/**
 * Spring MVC controller for 'UserNotification' management.
 */
@RequestMapping("/v1/auth/user")
@Controller
public class UserRestController extends AbstractRestController {
	@Autowired
	private ShareHistoryService shareHistoryService;
	@Autowired
	private UserService userService;
	@Autowired
	private UserNotificationService userNotificationService;
	@Autowired
	private RequestUserPsychologicalService requestUserPsychologicalService;
	@Autowired
	private VoucherUserService voucherUserService;
	@Autowired
	private CounselorService counselorService;
	@Autowired
	private VoucherService voucherService;
	@Autowired
	private UserReceiveMessageService userReceiveMessageService;
	@Autowired
	private MessageService messageService;
	@Autowired
	private NotificationService notificationService;
	@Autowired
	private CounselingSessionService counselingSessionService;
	@Autowired
	private PaymentHistoryService paymentHistoryService;
	@Autowired
	private UserNoticeService userNoticeService;
	@Autowired
	private NoticeService noticeService;
	@Autowired
	private CounselorScheduleSettingService counselorScheduleSettingService;
	@Autowired
	private UserQuestionaireService userQuestionaireService;
	@Autowired
	private TestResultService testResultService;
	@Autowired
	private AnswerService answerService;
	@Autowired
	private SelfDiagnosisAnswerService selfDiagnosisAnswerService;
	@Autowired
	private SelfDiagnosisResultsService selfDiagnosisResultsService;
	@Autowired
	private QuestionService questionService;
	@Autowired
	private PasswordHistoryService passwordHistoryService;
	@Autowired
	private UserPsychologicalService userPsychologicalService;
	@Autowired
	private UserPsychologicalFileService userPsychologicalFileService;
	@Autowired
	private ApplicationEventPublisher applicationEventPublisher;

	@RequestMapping(value = "/identity", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	public HashMap<String, Object> identity(@RequestParam(required = false) String uuid,
			HttpServletRequest httpRequest) {

		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);

		Map<String, Object> data = new HashMap<>();

		// calculate unread notification
		//// count all public notification
		Map<String, Object> notificationParams = new HashMap<>();
		notificationParams.put("types", new Short[] { 2 });
		long totalPublicNotification = notificationService.countNotification(notificationParams);
		long totalReadNotification;
		long totalUnreadNotification;

		// authenticated user
		if (user != null) {
			User u = userService.findById(user.getId());

			// filter messages
			Page<UserReceiveMessageEntity> messages = userReceiveMessageService.filterByUser(u.getId(),
					new Short[] { 0 }, 1, 10);

			data.put("id", u.getId());
			data.put("username", u.getUsername());
			data.put("email", u.getEmail());
			data.put("dayOfBirth", u.getDayOfBirth());
			data.put("fullname", u.getFullname());
			data.put("coins", u.getCoin());
			data.put("vouchers", voucherUserService.totalVourcherByUserId(u.getId()));
			data.put("messages", messages.getContent().size());

			// count all read userNotification by user
			Map<String, Object> userNotificationParamsRead = new HashMap<>();
			userNotificationParamsRead.put("userId", u.getId());
			userNotificationParamsRead.put("reads", new Short[] { 1 });
			totalReadNotification = userNotificationService.countNotification(userNotificationParamsRead);

			// count all unread userNotification by user
			Map<String, Object> userNotificationParamsUnread = new HashMap<>();
			userNotificationParamsUnread.put("userId", u.getId());
			userNotificationParamsUnread.put("reads", new Short[] { 0 });
			totalUnreadNotification = userNotificationService.countNotification(userNotificationParamsUnread);
			data.put("notifications", totalPublicNotification - totalReadNotification + totalUnreadNotification);

			// filter counseling session that haven't counseled
			Short actived =1;
			Integer roleId = Integer.valueOf(user.getRole());
			if(roleId == ApplicationDefine.USER_ROLE_MONITERING){
				actived = 0;
			}
			Map<String, Object> sessionParams = new HashMap<>();
			sessionParams.put("sorts", "startTime");
			sessionParams.put("direction", "ASC");
			sessionParams.put("page", 1);
			sessionParams.put("size", 10);
			sessionParams.put("userId", user.getId());
			sessionParams.put("actived", actived);
			Page<CounselingSessionEntity> counselingSessionEntities = counselingSessionService.filter(sessionParams);
			
			data.put("counselingSession", null);
			data.put("counselors", null);
			
			//counseling exists
			if (!counselingSessionEntities.getContent().isEmpty()) {
				sessionParams.put("forMain", "true");
				sessionParams.put("statuses", new Short[] { ApplicationDefine.CounselingSessionStatus.NOT_COUNSELED.getCode()});
				Page<CounselingSessionEntity> counselingSessionEntitiesScheduled = counselingSessionService.filter(sessionParams);
				if (!counselingSessionEntitiesScheduled.getContent().isEmpty()) {
					CounselingSessionEntity counselingSessionEntity = counselingSessionEntitiesScheduled.getContent().get(0);
					Map<String, Object> counselingSession = new HashMap<>();
					counselingSession.put("id", counselingSessionEntity.getId());
					counselingSession.put("startTime", counselingSessionEntity.getStartTime());
					counselingSession.put("endTime", counselingSessionEntity.getEndTime());
					counselingSession.put("counselorId", counselingSessionEntity.getCounselor().getId());
					counselingSession.put("counselorName",(userService.findById(counselingSessionEntity.getCounselor().getId()).getFullname()));
					data.put("counselingSession", counselingSession);
				} else {
					//have not counseling session now and have yet counseling one time
					int totalCounselorToDisplay = 3;
					List<Map<String, Object>> recentCounselors = new ArrayList<>(3);
					List<CounselorEntity> counselors = new ArrayList<>();
					List<Integer> counselorIds = new ArrayList<>();
					
					for (CounselingSessionEntity c : counselingSessionEntities.getContent()) {
						if(!counselors.contains(c.getCounselor())) {
							counselors.add(c.getCounselor());
						}
					}
					String categories = counselingSessionEntities.getContent().get(counselingSessionEntities.getContent().size() -1).getCounselingField();
					if (categories == null) {
						categories = "1";
					}
					
					List<SuggestionCounselor> suggestionCounselor = counselorService.counselorsByCategorySelected(","+categories+",", actived);

					// query recent counselor
					if (counselors.size() > 0) {
						// if recent counselor < totalCounselorToDisplay
						if(counselors.size() < 3) {
							for (CounselorEntity cse : counselors) {
								if (recentCounselors.size() < totalCounselorToDisplay) {
									if(!recentCounselors.contains(cse)) {
										Map<String, Object> counselorMap = new HashMap<>();
										counselorMap.put("id", cse.getId());
										counselorMap.put("name", cse.getUser().getFullname());
										counselorMap.put("avatar", cse.getThumbnailUrl());
										counselorMap.put("counselorField", categories);
										recentCounselors.add(counselorMap);
										counselorIds.add(cse.getId());
									}
								}
							}
							
							
							for (int i = recentCounselors.size(); i < 4; i++) {
								for (int j = 0; j < suggestionCounselor.size(); j++) {
									if (!counselorIds.contains(suggestionCounselor.get(j).getCounselorEntity().getId())) {
										Map<String, Object> counselorMap = new HashMap<>();
										counselorMap.put("id", suggestionCounselor.get(j).getCounselorEntity().getId());
										counselorMap.put("name", suggestionCounselor.get(j).getFullName());
										counselorMap.put("avatar", suggestionCounselor.get(j).getCounselorEntity().getThumbnailUrl());
										counselorMap.put("counselorField", categories);
										recentCounselors.add(counselorMap);
										counselorIds.add(suggestionCounselor.get(j).getCounselorEntity().getId());
									} if (recentCounselors.size() == 3) {
										break;
									}
								}
							}
							
						} else {
							// if recent counselor >= totalCounselorToDisplay
							for (CounselorEntity cse : counselors) {
								if (recentCounselors.size() < totalCounselorToDisplay) {
									Map<String, Object> counselorMap = new HashMap<>();
									counselorMap.put("id", cse.getId());
									counselorMap.put("name", cse.getUser().getFullname());
									counselorMap.put("avatar", cse.getThumbnailUrl());
									counselorMap.put("counselorField", categories);
									recentCounselors.add(counselorMap);
								}
							}
						}
						
					} else {
						for (SuggestionCounselor sg : suggestionCounselor) {
							if (recentCounselors.size() < totalCounselorToDisplay) {
								Map<String, Object> counselorMap = new HashMap<>();
								counselorMap.put("id", sg.getCounselorEntity().getId());
								counselorMap.put("name", sg.getFullName());
								counselorMap.put("avatar", sg.getCounselorEntity().getThumbnailUrl());
								counselorMap.put("counselingField", categories);
								recentCounselors.add(counselorMap);
							}
						}
					}
					
					// query next 3 counselor related to category
					data.put("counselors", recentCounselors);
				}
			}
		}
		// unauthorized user
		else {
			// count all read userNotification by uuid
			Map<String, Object> userNotificationParams = new HashMap<>();
			userNotificationParams.put("uuid", uuid);
			userNotificationParams.put("reads", new Short[] { 1 });
			totalReadNotification = userNotificationService.countNotification(userNotificationParams);

			data.put("id", null);
			data.put("username", null);
			data.put("fullname", null);
			data.put("coins", null);
			data.put("notifications", totalPublicNotification - totalReadNotification);
			data.put("vouchers", null);
			data.put("counselingSession", null);
			data.put("counselors", null);
		}

		return SUCCESS(data);
	}

	@RequestMapping(value = "/update", method = RequestMethod.PUT)
	@ResponseBody
	public HashMap<String, Object> update(@RequestParam Map<String, Object> params, HttpSession session) {
		UserItem user = Login.getMobileLogin(session);
		User u = userService.findById(user.getId());

		if (u == null) {
			return FAIL("User is not found");
		}

		try {
			if (params.get("status") != null) {
				u.setStatusActive(Short.valueOf(params.get("status").toString()));
			}
		} catch (Exception e) {
			e.printStackTrace();
			return ERROR("HAVE ERROR: " + e);
		}
		return SUCCESS();
	}

	@RequestMapping(value = "/myHello", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getMyHello(HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			MyHello myHello = new MyHello();
			myHello.setFullname(u.getFullname());
			myHello.setCoin(u.getCoin());
			myHello.setVoucherNumber(voucherUserService.totalVoucherNoUsedByUserId(u.getId()));

			List<CounselingSession> counselingSessions = counselingSessionService.findEarliestCounselingTime(u.getId());
			if (counselingSessions.size() > 0) {
				CounselingSession earliestCounseling = counselingSessions.get(0);
				Date startTimeOfEarliestCounseling = earliestCounseling.getStartTime();
				myHello.setEarliestCounselingTime(startTimeOfEarliestCounseling.getTime());
				myHello.setStatusCounselingTime(1);
			} else {
				myHello.setEarliestCounselingTime((long) 0);
				myHello.setStatusCounselingTime(0);
			}

			Page<UserReceiveMessageEntity> messages = userReceiveMessageService.filterByUser(u.getId(),
					new Short[] { 0 }, 1, 10);
			if (messages.getContent().size() > 0) {
				myHello.setIsReadMessage(0);
			} else {
				myHello.setIsReadMessage(1);
			}
			myHello.setHeart(u.getHeart());

			if (u.getRoleId() == 5) {
				myHello.setIsShowMenu(1);
			} else {
				myHello.setIsShowMenu(0);
			}

			Voucher voucher = voucherService.findByTypeHeart((short) 2);
			ret.put("heartNumberConvert", voucher.getHeartNumber());
			ret.put("heartUser", u.getHeart());
			ret.put("voucherId", voucher.getId());
			if (u.getHeart() >= voucher.getHeartNumber()) {
				ret.put("disableButton", 0);
			} else {
				ret.put("disableButton", 1);
			}

			ret.put("myHello", myHello);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/helloCoinSummary", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getHelloCoinSummary(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			ret.put("coin", u.getCoin());
			int page = 1;
			if (params.get("page") != null) {
				page = (Integer.valueOf(params.get("page").toString()));
			}
			int totalRecharge = 0;
			Page<PaymentHistoryEntity> listPage = paymentHistoryService.listPagingByUserIdAndTypeCoin(u.getId(), ApplicationDefine.Payment_TypeCoin.Coin.getCode(), page, 10);
			List<HelloCoinSummary> list = new ArrayList<>();
			if (listPage.getContent() != null && listPage.getContent().size() > 0) {
				for (PaymentHistoryEntity i : listPage) {
					HelloCoinSummary h = new HelloCoinSummary();
					h.setCoin(i.getCoin());
					h.setCreateDate(i.getCreateDate());
					h.setCurrentCoin(i.getCurrentCoin());
					if (i.getTypePayment() == 1) {
						h.setIsIncrease(1);
					} else {
						h.setIsIncrease(0);
					}
					h.setReason(i.getReason());
					list.add(h);
				}
				ret.put("isNotHistoryRecharge", 0);
				totalRecharge = paymentHistoryService.totallistPagingByUserId(u.getId());
			} else {
				ret.put("isNotHistoryRecharge", 1);
			}

			ret.put("totalRecharge", totalRecharge);
			ret.put("historyRecharges", list);

			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/helloVoucherSummary", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getHelloVoucherSummary(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			if (u != null) {
				int offset = 0;
				if (params.get("offset") != null) {
					offset = (Integer.valueOf(params.get("offset").toString()));
				}

				List<HelloVoucherSummary> voucherList = new ArrayList<>();
				ret.put("voucher", voucherUserService.totalVoucherNoUsedByUserId(u.getId()));
				Integer totalVoucherByUser = voucherUserService.totalVoucherByUserId(u.getId());
				ret.put("totalVoucherByUser", totalVoucherByUser);
				if (totalVoucherByUser > 0) {
					voucherList = voucherUserService.voucherUserEntitiesByUserIdLoadMore(u.getId(), offset, 5);
				}
				ret.put("voucherList", voucherList);
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/myReservation", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getMyReservation(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			List<MyReservation> reservationsList = counselingSessionService.counselingSessionEntitiesByUserId(u.getId());
			if (reservationsList.size() > 0) {
				ret.put("statusReservation", 1);
			} else {
				ret.put("statusReservation", 0);
			}
			ret.put("reservationsList", reservationsList);

			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/reservationDetail", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationDetail(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer id = (Integer.valueOf(params.get("id").toString()));
			MyReservation myReservation = counselingSessionService.myReservationByCounselingSessionId(id, u.getId());
			ret.put("reservationDetail", myReservation);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/cancelResevation", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> cancelResevation(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer id = (Integer.valueOf(params.get("id").toString()));
			ret.put("id", id);
			MyReservation myReservation = counselingSessionService.myReservationByCounselingSessionId(id, u.getId());
			Date startTimeCounseling = myReservation.getStartTimeCounseling();
			Date currentDate = new Date();
			Long diffDays = currentDate.getTime() - startTimeCounseling.getTime();
			if (diffDays > 86400000) {
				ret.put("statusCancelReservation", 0);
			} else if (diffDays <= 86400000 && diffDays >= 3600000) {
				ret.put("statusCancelReservation", 1);
			} else {
				ret.put("statusCancelReservation", 2);
			}
			ret.put("startTime", startTimeCounseling);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/refundResevation", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> refundResevation(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer id = (Integer.valueOf(params.get("id").toString()));
			Integer status = (Integer.valueOf(params.get("statusCancelReservation").toString()));
			MyReservation myReservation = counselingSessionService.myReservationByCounselingSessionId(id, u.getId());
			PaymentHistory paymentHistory = paymentHistoryService.findById(myReservation.getPaymentId());
			if (status == 0) {
				if (paymentHistory.getTypeCoin() == 1) {

				} else {

				}
			} else if (status == 1) {
				if (paymentHistory.getTypeCoin() == 1) {

				} else {

				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/myCounseling", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getMyCounseling(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());

			int page = 1;
			if (params.get("page") != null) {
				page = (Integer.valueOf(params.get("page").toString()));
			}
			List<MyReservation> completedCounselingList = new ArrayList<>();
			List<CompletedCounselingListByYear> completedCounselingListByYears = new ArrayList<>();
			int totalCompletedCounseling = counselingSessionService.totalCompletedCounselingHistoryByUser(u.getId());
			if (totalCompletedCounseling > 0) {
				completedCounselingList = counselingSessionService.counselingSessionHistoryByUserId(page, 30, u.getId());
				Integer[] years = counselingSessionService.getYearCompletedCounseling(u.getId());
				for (int i = 0; i < years.length; i++) {

					SimpleDateFormat df = new SimpleDateFormat("yyyy");
					if (years[i] != null) {
						List<MyReservation> completedCounselingListByYear = new ArrayList<>();
						for (MyReservation myReservation : completedCounselingList) {
							String yearInCompletedCounseling = df.format(myReservation.getEndTimeCounseling());
							int yearInCompletedCounselingConvert = Integer.valueOf(yearInCompletedCounseling);
							int year = years[i].intValue();
							if (yearInCompletedCounselingConvert == year) {
								completedCounselingListByYear.add(myReservation);
							}
						}
						if (completedCounselingListByYear.size() > 0) {
							CompletedCounselingListByYear c = new CompletedCounselingListByYear();
							c.setYear(years[i]);
							c.setCompletedCounselingList(completedCounselingListByYear);
							completedCounselingListByYears.add(c);
						}
					}
				}
			}
			ret.put("totalCompletedCounseling", totalCompletedCounseling);
			ret.put("completedCounselingListByYears", completedCounselingListByYears);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/inboxMessage", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getInboxMessage(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			List<InboxMessage> list = userReceiveMessageService.filterByUser(u.getId());
			if (list.size() > 0) {
				ret.put("statusInboxMessage", 1);
			} else {
				ret.put("statusInboxMessage", 0);
			}
			ret.put("messageList", list);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/messageDetail", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getInboxMessageDetail(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer id = (Integer.valueOf(params.get("id").toString()));
			InboxMessage iMessage = userReceiveMessageService.findByUserReceiMessageId(id, u.getId());
			ret.put("messageDetail", iMessage);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/sendMessageDetail", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getSendMessageDetail(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer id = (Integer.valueOf(params.get("id").toString()));
			InboxMessage iMessage = userReceiveMessageService.findByUserReceiMessageIdInApp(id, u.getId());
			ret.put("messageDetail", iMessage);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}
	
	
	@RequestMapping(value = "/deleteMessage ", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> deleteMessage(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			if (u != null) {
				Integer id = (Integer.valueOf(params.get("id").toString()));
				Integer notificationId = (Integer.valueOf(params.get("notificationId").toString()));
				userReceiveMessageService.updateIsDeleteByMessageId(id);
				System.out.println("notificationId:" + notificationId);
				UserNotification userNotification = new UserNotification();
				if (notificationId != 0) {
					userNotification = userNotificationService.findByUserIdAndNotifiId(u.getId(), notificationId);
					if (userNotification != null) {
						userNotificationService.deleteByNotificationId(notificationId, u.getId());
					}
				} else {
					userNotificationService.deleteByUserIdAndUserReceiveMessId(u.getId(), id);
				}
				
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/sentMessage", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> sentMessage(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			List<InboxMessage> list = userReceiveMessageService.listSentMessage(u.getId());
			if (list.size() > 0) {
				ret.put("statusSentMessage", 1);
			} else {
				ret.put("statusSentMessage", 0);
			}
			ret.put("messageList", list);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/writeMessage", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> writeMessage(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
			String contentMessage = params.get("contentMessage").toString();
			Message message = new Message();
			message.setSendUserId(u.getId());
			message.setContent(contentMessage);
			message.setSendDate(new Date());
			message.setRecieveDate(new Date());
			message.setUpdateDate(new Date());
			message.setCreateDate(new Date());
			message.setTypeUser(1);
			message = messageService.create(message);

			UserReceiveMessage um = new UserReceiveMessage();
			um.setUserId(counselorId);
			um.setMessageId(message.getId());
			um.setStatus((short) 0);
			um.setCreateDate(new Date());
			um.setUpdateDate(new Date());
			um = userReceiveMessageService.create(um);

			applicationEventPublisher.publishEvent(new CounselorMessageAddedEvent(this, u.getId(), counselorId, message.getId()));

			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/updateStatusMessage", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> updateStatusMessage(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			if (u != null) {
				Integer id = (Integer.valueOf(params.get("id").toString()));
				UserReceiveMessage uMessage = userReceiveMessageService.findById(id);
				uMessage.setStatus((short) 1);
				uMessage.setUpdateDate(new Date());
				uMessage = userReceiveMessageService.update(uMessage);
			}

			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/announcements", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getNotices(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			List<Announcement> announcements = new ArrayList<>();
			if (u.getBusinessSubId()!= null) {
				announcements = userNoticeService.listAnnouncement(u.getId());
				ret.put("statusAnnouncements", 1);
			} else {
				ret.put("statusAnnouncements", 0);
			}

			ret.put("announcements", announcements);
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/updateStatusAnnouncement", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> updateStatusAnnouncement(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			if (u != null) {
				Integer id = (Integer.valueOf(params.get("id").toString()));
				UserNotice userNotice = userNoticeService.findById(id);
				userNotice.setStatus(1);
				userNotice.setUpdateDate(new Date());
				userNotice = userNoticeService.update(userNotice);

				Notice n = noticeService.findById(userNotice.getNoticeId());
				n.setViewNumber(n.getViewNumber() + 1);
				n = noticeService.update(n);
			}

			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/announcementDetail", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getNoticeDetail(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		String token = httpRequest.getHeader("token");
		UserItem user = AuthorizationToken.convertToObject(token);
		HashMap<String, Object> ret = new HashMap<String, Object>();
		try {
			User u = userService.findById(user.getId());
			if (u != null) {
				Integer id = (Integer.valueOf(params.get("id").toString()));
				Announcement announcement = new Announcement();
				announcement = userNoticeService.getAnnouncementByUserNoticeId(id);
				ret.put("announcementDetail", announcement);
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/reservation/reservationDate ", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationDate(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				if (u != null) {
					Integer month = (Integer.valueOf(params.get("month").toString()));
					Integer year = (Integer.valueOf(params.get("year").toString()));
					Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
					Integer typeCounseling = (Integer.valueOf(params.get("typeCounseling").toString()));
					Counselor counselor = counselorService.findById(counselorId);
					List<ReservationDate> listSettings = counselorScheduleSettingService.listByMonth(month, counselorId,year, counselor.getCounselingRestTime());		
					List<Date> list = Utils.getDaysByMonth(year, month, Utils.getDate(month, year), listSettings);
					ret.put("month", month);
					ret.put("counselorId", counselorId);
					ret.put("reservationDates", listSettings);
					ret.put("typeCounseling", typeCounseling);
					ret.put("noReservationDates", list);
					ret.put("counselingRestTime", counselor.getCounselingRestTime());
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}
	
	@RequestMapping(value = "/reservation/reservationTime", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationTime2(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				if (u != null) {
					long datet = (Long.valueOf(params.get("reservationDate").toString()));
					Date dateReservation = new Date(datet);
					Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
					Integer typeCounseling = (Integer.valueOf(params.get("typeCounseling").toString()));
					Counselor counselor = counselorService.findById(counselorId);
					TreeMap<Float, ReservedAndCounselingType> listStartTimeCounselingSSByDay = counselingSessionService.listStartTimeCounselingSSByDay(dateReservation, counselorId);
					CounselorScheduleSetting counselorScheduleSetting = counselorScheduleSettingService.findCounselorScheduleSettingByReservationDate(dateReservation, counselorId);
					Integer counselingTime = 30;
					if(typeCounseling == 2){
						counselingTime = 50;
					}
					List<ReservationTimeSelect> reservationTimes = new ArrayList<>();
					if (counselorScheduleSetting != null) {
						reservationTimes = Utils.getTimeCanReserve(counselingTime, 
																	counselor.getCounselingRestTime(), 
																	dateReservation, 
																	counselorScheduleSetting.getReservationTime(),
																	listStartTimeCounselingSSByDay);
					
					}
					ret.put("reservationTimes", reservationTimes);
					ret.put("counselorId", counselorId);
					ret.put("reservationDate", dateReservation);
					ret.put("counselingRestTime", counselor.getCounselingRestTime());
					ret.put("typeCounseling", typeCounseling);
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/reservation/complete1", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationComplete1(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				
				Integer typeCounseling = (Integer.valueOf(params.get("typeCounseling").toString()));
				Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
				long reservationDate = (Long.valueOf(params.get("reservationDate").toString()));
				String userReservationTime = String.valueOf(params.get("userReservationTime"));
				
				Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(user.getId());
				String[] time = userReservationTime.split("~");
				Calendar startTime = Calendar.getInstance();
				startTime.setTimeInMillis(reservationDate);
				String[] hour1 = time[0].trim().split(":");
				startTime.set(Calendar.HOUR_OF_DAY, Integer.valueOf(hour1[0]));
				startTime.set(Calendar.MINUTE, Integer.valueOf(hour1[1]));
				startTime.set(Calendar.SECOND, 0);
				Calendar endTime = Calendar.getInstance();
				endTime.setTimeInMillis(reservationDate);
				String[] hour2 = time[1].trim().split(":");
				endTime.set(Calendar.HOUR_OF_DAY, Integer.valueOf(hour2[0]));
				endTime.set(Calendar.MINUTE, Integer.valueOf(hour2[1]));
				endTime.set(Calendar.SECOND, 0);
				int exists = counselingSessionService.countBy(startTime.getTime(), endTime.getTime(), counselorId);
				if (exists > 0) {
					return FAIL_RESERVATION();
				}
				User u = userService.findById(user.getId());
				Counselor c = counselorService.findById(counselorId);
				Integer fee = 0;
				if(u.getRoleId() == ApplicationDefine.USER_ROLE_MONITERING){
					fee = 0;
				}else if(typeCounseling == 1){
					fee = c.getFeeCounselor();
				}else{
					fee = c.getFeeCounselor50Minutes();
				}
				VoucherUser v = voucherUserService.getVoucherCanUse(user.getId(), typeCounseling);
				if (v != null  || u.getCoin() >= fee) {
					ret.put("showPopup", 1);
				} else {
					ret.put("showPopup", 2);
				}
				ret.put("currentCoin", u.getCoin());
				ret.put("currentVoucher", countVoucher);
				ret.put("counselorId", counselorId);
				ret.put("reservationDate", reservationDate);
				ret.put("userReservationTime", userReservationTime);
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/reservation/cancel ", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationCancel(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			UserItem user = AuthorizationToken.convertToObject(token);
			User u = userService.findById(user.getId());
			Integer reservationId = (Integer.valueOf(params.get("reversionId").toString()));
			CounselingSession c = counselingSessionService.findByIdAnhUserId(u.getId(), reservationId);
			Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(u.getId());
			if (c != null) {
				if (c.getStatus() == 0) {
					return FAIL("This reservation is canceled");
				}
				c.setStatus(ApplicationDefine.CounselingSession_Status.RESERVATION_CANCEL.getCode());
				c.setCancelMettingTime(new Date());
				counselingSessionService.update(c);
				if (c.getPaymentId() != null) {
					Date now = new Date();
					Integer diffHour = (int)(( c.getStartTime().getTime() - now.getTime())/ (1000 * 60 * 60));
					PaymentHistory p = paymentHistoryService.findById(c.getPaymentId());
					if (p.getTypeCoin() == 3 && p.getVoucherUserId() != null) {
						if(diffHour >= 1){
							VoucherUser v = voucherUserService.findById(p.getVoucherUserId());
							v.setStatusUse((short) ApplicationDefine.VoucherUser_Status.CanUse.getCode());
							v.setUseVoucherDate(null);
							voucherUserService.update(v);
							userService.updateVoucherNumberByUserId(u.getId());
							ret.put("currentCoin", u.getCoin());
							ret.put("currentVoucher", countVoucher+1);
							p.setVoucherUserId(null);
						}
						p.setStatus((short)ApplicationDefine.Payment_Status.Cancel.getCode());
						paymentHistoryService.update(p);
					}else{
						if(diffHour >= 6){
							Integer[] userCoin = userService.updateCoin(u, p.getCoin());
							p.setUserId(user.getId());
							p.setStatus((short) 1);
							p.setTypeCoin(ApplicationDefine.Payment_TypeCoin.Coin.getCode());
							p.setTypeUse(ApplicationDefine.Recharge_TypeUse.CancelReservation.getCode());
							p.setReason(ApplicationDefine.Recharge_Reson.CancelReservation.getCode());
							p.setTypePayment(ApplicationDefine.Payment_TypePaymentStatus.Recharge.getCode());
							p.setCoin(userCoin[0]);
							p.setCurrentCoin(userCoin[1]);
							p.setCreateDate(new Date());
							p.setUpdateDate(new Date());
							p.setId(null);
							paymentHistoryService.create(p);
							ret.put("currentCoin", userCoin[1]);
							ret.put("currentVoucher", countVoucher);
							
						}else if(diffHour < 6 && diffHour >= 1){
							Double coin = (p.getCoin()*0.5);
							Integer coinRefund = coin.intValue();
							Integer[] userCoin = userService.updateCoin(u,coinRefund );
							p.setUserId(user.getId());
							p.setStatus((short) 1);
							p.setTypeCoin(ApplicationDefine.Payment_TypeCoin.Coin.getCode());
							p.setTypeUse(ApplicationDefine.Recharge_TypeUse.CancelReservation.getCode());
							p.setReason(ApplicationDefine.Recharge_Reson.CancelReservation.getCode());
							p.setTypePayment(ApplicationDefine.Payment_TypePaymentStatus.Recharge.getCode());
							p.setCoin(userCoin[0]);
							p.setCurrentCoin(userCoin[1]);
							p.setCreateDate(new Date());
							p.setUpdateDate(new Date());
							p.setId(null);
							paymentHistoryService.create(p);
							ret.put("currentCoin", userCoin[1]);
							ret.put("currentVoucher", countVoucher);
						}
					}
				}
				
				return SUCCESS(ret);

			} else {
				ret.put("cancelSuccess", 0);
				ret.put("error", "reversionId for this user is not exists");
				return FAIL("reversionId for this user is not exists");
			}
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/psychological_test/payment", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> psychological_test(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			Integer requestId = (Integer.valueOf(params.get("requestId").toString()));
			String email = (params.get("email").toString());
			RequestUserPsychological r = requestUserPsychologicalService.findById(requestId);
			Integer fee = r.getFee();
			String token = httpRequest.getHeader("token");
			UserItem user = AuthorizationToken.convertToObject(token);
			User u = userService.findById(user.getId());
			Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(user.getId());
			HashMap<String, Object> ret = new HashMap<>();
			if (fee > u.getCoin()) {
				ret.put("success", 0);
			} else {
				Integer[] userCoin = userService.updateCoin(u, -fee);
				PaymentHistory paymentHistory = new PaymentHistory();
				paymentHistory.setUserId(user.getId());
				paymentHistory.setStatus((short) 1);
				paymentHistory.setTypeCoin(ApplicationDefine.Payment_TypeCoin.Coin.getCode());
				paymentHistory.setTypeUse(ApplicationDefine.PaymentTypeUse.Psychological.getCode());
				paymentHistory.setTypePayment(ApplicationDefine.Payment_TypePaymentStatus.Payment.getCode());
				paymentHistory.setReason(ApplicationDefine.Payment_Reson.PaymentPsychologicalTest.getCode());
				paymentHistory.setCoin(userCoin[0]);
				paymentHistory.setCurrentCoin(userCoin[1]);
				paymentHistory.setCreateDate(new Date());
				paymentHistory.setUpdateDate(new Date());
				PaymentHistory payment = paymentHistoryService.create(paymentHistory);
				ret.put("currentCoin", userCoin[1]);
				ret.put("currentVoucher", countVoucher);
				r.setPaymentId(payment.getId());
				r.setEmail(email);
				r.setPaymentPsychological(new Date());
				r.setStatus((short) 1);
				RequestUserPsychological create=  requestUserPsychologicalService.update(r);
				ret.put("success", 1);
				
				List<UserPsychologicalEntity> list = userPsychologicalService.listByRequestId(r.getId());
				Integer numberGuide = 0;
				Integer numberAssets = 0;
				String html ="";

				List<PsychologicalTestSetting> listGuide = new ArrayList<>();
				List<PsychologicalTestSetting> listAssets = new ArrayList<>();
				List<String> testSiteCompanyNames 	= new ArrayList<>();
				
				for (UserPsychologicalEntity i : list) {
					String testSiteCompanyName = i.getPsychologicalTestSetting().getCompanyName();
					if (!testSiteCompanyNames.contains(testSiteCompanyName)) {
						testSiteCompanyNames.add(testSiteCompanyName);
					}
					
					if(i.getPsychologicalTestSetting().getCompanyName().equals("가이던스")){
						numberGuide++;
						PsychologicalTestSetting p = new PsychologicalTestSetting();
						p.setCompanyName(i.getPsychologicalTestSetting().getCompanyName());
						p.setTestName(i.getPsychologicalTestSetting().getTestName());
						p.setUrl(i.getPsychologicalTestSetting().getUrl());
						listGuide.add(p);
					}else{
						numberAssets++;
						PsychologicalTestSetting p = new PsychologicalTestSetting();
						p.setCompanyName(i.getPsychologicalTestSetting().getCompanyName());
						p.setTestName(i.getPsychologicalTestSetting().getTestName());
						p.setUrl(i.getPsychologicalTestSetting().getUrl());
						listAssets.add(p);
					}
				}
				
				Integer totalRowSpan = numberGuide + numberAssets+1;
				if(numberGuide > 0){
					numberGuide++;
					totalRowSpan++;
				}
				if(numberAssets > 0){
					numberAssets++;
					totalRowSpan++;
				}
				HashMap<String, Object> mailParams = new HashMap<>();
				mailParams.put("createDate", DataUtils.parseStringFromDate(new Date(), "yyyy MM월 dd일  HH:mm:ss"));
				mailParams.put("fullname", u.getFullname());
				User counselor = userService.findById(r.getCounselorId());
				mailParams.put("email", r.getEmail());
				mailParams.put("content", html);
				mailParams.put("totalRowSpan", totalRowSpan);
				mailParams.put("numberGuide", numberGuide);
				mailParams.put("numberAssets", numberAssets);
				mailParams.put("listGuide", listGuide);
				mailParams.put("listAssets", listAssets);
				System.out.println(html);

				Mail.sendEmailTemplate(counselor.getEmail(), mailParams, EmailTemplate.COMPLETE_PSYCHOLOGICAL_TEST,"[Hello] "+u.getFullname()+ApplicationDefine.EmailSubject.COMPLETE_PSYCHOLOGICAL_TEST.getCode());
				applicationEventPublisher.publishEvent(new PsyTestPaymentAddedEvent(this, u.getId(), counselor.getId(), create.getId(), testSiteCompanyNames.toString()));
			}
			
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/reservation/complete1_popup1", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getReservationComplete2(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd");
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
				Integer typeCounseling = (Integer.valueOf(params.get("typeCounseling").toString()));
				long reservationDate = (Long.valueOf(params.get("reservationDate").toString()));
				String userReservationTime = String.valueOf(params.get("userReservationTime"));
				String counselingField = String.valueOf(params.get("counselingField"));
				String osName ="android";
				try {
					osName = String.valueOf(params.get("osName"));
				} catch (Exception e) {
					// TODO: handle exception
				}
				Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(u.getId());
				String[] time = userReservationTime.split("~");
				Calendar startTime = Calendar.getInstance();
				startTime.setTimeInMillis(reservationDate);
				String[] hour1 = time[0].trim().split(":");
				startTime.set(Calendar.HOUR_OF_DAY, Integer.valueOf(hour1[0]));
				startTime.set(Calendar.MINUTE, Integer.valueOf(hour1[1]));
				startTime.set(Calendar.SECOND, 0);
				Calendar endTime = Calendar.getInstance();
				endTime.setTimeInMillis(reservationDate);
				String[] hour2 = time[1].trim().split(":");
				endTime.set(Calendar.HOUR_OF_DAY, Integer.valueOf(hour2[0]));
				endTime.set(Calendar.MINUTE, Integer.valueOf(hour2[1]));
				endTime.set(Calendar.SECOND, 0);
				int exists = counselingSessionService.countBy(startTime.getTime(), endTime.getTime(), counselorId);
				if (exists > 0) {
					ret.put("currentCoin",  u.getCoin());
					ret.put("currentVoucher", countVoucher);
					return FAIL("현재 상담사가 상담중입니다.");
				}
				Counselor c = counselorService.findById(counselorId);
				VoucherUser v = voucherUserService.getVoucherCanUse(u.getId(), typeCounseling);

				PaymentHistory paymentHistory = new PaymentHistory();
				paymentHistory.setUserId(user.getId());
				paymentHistory.setStatus((short) 1);
				paymentHistory.setTypeUse(ApplicationDefine.PaymentTypeUse.Reservation.getCode());
				paymentHistory.setReason(ApplicationDefine.Payment_Reson.Reverstation.getCode());
				paymentHistory.setTypePayment(ApplicationDefine.Payment_TypePaymentStatus.Payment.getCode());
				paymentHistory.setCreateDate(new Date());
				paymentHistory.setUpdateDate(new Date());
				if (v != null) {
					paymentHistory.setTypeCoin(ApplicationDefine.Payment_TypeCoin.Voucher.getCode());
					paymentHistory.setCoin(0);
					paymentHistory.setCurrentCoin(u.getCoin());
					paymentHistory.setVoucherUserId(v.getId());
					try {
						Voucher voucher = voucherService.findById(v.getVoucherId());
						paymentHistory.setCoin(voucher.getFee());
					} catch (Exception e) {
						// TODO: handle exception
					}
					v.setStatusUse(ApplicationDefine.VoucherUser_Status.Used.getCode());
					v.setUpdateDate(new Date());
					v.setUseVoucherDate(new Date());
					ret.put("currentCoin",  u.getCoin());
					ret.put("currentVoucher", countVoucher);
					voucherUserService.update(v);
					userService.updateVoucherNumberByUserId(u.getId());
				} else {
					Integer fee = 0;
					if(u.getRoleId() == ApplicationDefine.USER_ROLE_MONITERING){
						fee = 0;
					}else if (typeCounseling == 1) {
						fee = c.getFeeCounselor();
					} else {
						fee = c.getFeeCounselor50Minutes();
					}
					
					if (fee > u.getCoin()) {
						ret.put("success", 0);
						ret.put("currentCoin",  u.getCoin());
						ret.put("currentVoucher", countVoucher);
						return SUCCESS(ret);
					} else {
						Integer[] userCoin = userService.updateCoin(u, -fee);
						paymentHistory.setTypeCoin(ApplicationDefine.Payment_TypeCoin.Coin.getCode());
						paymentHistory.setCoin(userCoin[0]);
						paymentHistory.setCurrentCoin(userCoin[1]);
						ret.put("currentCoin", userCoin[1]);
						ret.put("currentVoucher", countVoucher);
					}
				}
				
				PaymentHistory payment = paymentHistoryService.create(paymentHistory);

				CounselingSession session = new CounselingSession();
				session.setCounselorId(Integer.parseInt(params.get("counselorId").toString()));
				session.setUserId(user.getId());
				session.setStartTime(startTime.getTime());
				session.setEndTime(endTime.getTime());
				session.setCounselType((short) 2);
				session.setPoint((float) 0);
				session.setSatisfactionRating((short) 0);
				session.setCreateDate(new Date());
				session.setUpdateDate(new Date());
				session.setStatus((short) 1);
				session.setOsName(osName);
				session.setIsDelete(0);
				if (typeCounseling == 1) {
					session.setCounselingTimeType((short) 30);
				} else {
					session.setCounselingTimeType((short) 50);
				}
				session.setCounselingField(counselingField);
				session.setPaymentId(payment.getId());
				session.setDisconnectCount(0);
				CounselingSession counselingSession = counselingSessionService.create(session);
				ret.put("success", 1);
				
				//checking mindcheck 
				UserQuestionaire userQuestionaire = userQuestionaireService.getHistoryMindcheck(u.getId());
				if (userQuestionaire != null) {
					Date createDate = userQuestionaire.getCreateDate();
					Date getDate3MonthsAgo = Utils.getDate3MonthsAgo();
					Date currentDate = new Date();

//					String createDateConvert = s.format(createDate);
//					String currentDateConvert = s.format(currentDate);
					if (createDate.after(getDate3MonthsAgo) && createDate.before(currentDate)) {
						ret.put("showPopup", 3);
//						if (createDateConvert.equals(currentDateConvert)) {
//							ret.put("showPopup", 5);
//						} else {
//							ret.put("showPopup", 3);
//						}
					} else {
						ret.put("showPopup", 4);
					}
				} else {
					ret.put("showPopup", 4);
				}
				
				ret.put("counselorId", counselorId);
				ret.put("reservationDate", reservationDate);
				ret.put("typeCounseling", typeCounseling);
				ret.put("userReservationTime", userReservationTime);
				applicationEventPublisher.publishEvent(new CounselingSessionScheduleAddedEvent(this, session.getUserId(), session.getCounselorId(), counselingSession.getId()));

			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/payment/confirmPaymentPopup", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> confirmPaymentPopup(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));
				Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(u.getId());

				if (u.getCoin() == 0) {
					ret.put("showPopup", 2);
				} else {
					ret.put("showPopup", 1);
				}
				ret.put("currentCoin", u.getCoin());
				ret.put("currentVoucher", countVoucher);
				ret.put("counselorId", counselorId);
			}

			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/payment/confirmPaymentPopup_popup1 ", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> confirmPaymentPopup_popup1(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd");
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				Integer counselorId = (Integer.valueOf(params.get("counselorId").toString()));

				UserQuestionaire userQuestionaire = userQuestionaireService.getHistoryMindcheck(u.getId());
				if (userQuestionaire != null) {
					Date createDate = userQuestionaire.getCreateDate();
					Date getDate3MonthsAgo = Utils.getDate3MonthsAgo();
					Date currentDate = new Date();

//					String createDateConvert = s.format(createDate);
//					String currentDateConvert = s.format(currentDate);
					if (createDate.after(getDate3MonthsAgo) && createDate.before(currentDate)) {
						ret.put("showPopup", 3);
//						if (createDateConvert.equals(currentDateConvert)) {
//							ret.put("showPopup", 5);
//						} else {
//							ret.put("showPopup", 3);
//						}
					} else {
						ret.put("showPopup", 4);
					}
				} else {
					ret.put("showPopup", 4);
				}
				ret.put("counselorId", counselorId);

			}
			return SUCCESS(ret);
		} catch (Exception e) {
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/evaluateSatisfaction/questions", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> evaluateSatisfaction(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			List<Question> list = new ArrayList<>();
			if (httpRequest.getHeader("token") != null) {
				list = questionService.listQuestionByIsShowQsn((short) 1);
				if (list.size() > 0) {
					ret.put("questionnaireId", list.get(0).getQuestionaireId());
				}
			}
			ret.put("questions", list);
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/evaluateSatisfaction/writeReview", method = { RequestMethod.POST,
			RequestMethod.GET }, produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> writeReview(@RequestHeader(value = "token", required = false) String token,
			@RequestBody String json) {
		UserItem user = AuthorizationToken.convertToObject(token);
		try {
			User u = userService.findById(user.getId());
			HashMap<String, Object> ret = new HashMap<String, Object>();
			GsonBuilder builder = new GsonBuilder();
			builder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
				public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
						throws JsonParseException {
					return new Date(json.getAsJsonPrimitive().getAsLong());
				}
			});

			JsonParser parser2 = new JsonParser();
			JsonObject jsonObject = parser2.parse(json).getAsJsonObject();
			JsonArray jsonArray = jsonObject.getAsJsonArray("QASatisfactionEvaluationList");
			Gson gson = builder.create();
			List<QASatisfactionEvaluation> qas = gson.fromJson(jsonArray.toString(),
					new TypeToken<List<QASatisfactionEvaluation>>() {
					}.getType());

			org.json.simple.parser.JSONParser parser = new JSONParser();
			JSONObject jsonObj = (JSONObject) parser.parse(json);
			String comment = (String) jsonObj.get("comment");
			Integer counselorId = (Integer.valueOf(jsonObj.get("counselorId").toString()));
			Short suggest = (Short.valueOf(jsonObj.get("suggest").toString()));
			Integer questionnaireId = (Integer.valueOf(jsonObj.get("questionnaireId").toString()));
			Integer counselingSessionId = (Integer.valueOf(jsonObj.get("counselingSessionId").toString()));
			
			UserQuestionaire userQuestionaire = new UserQuestionaire();
			userQuestionaire.setId(0);
			userQuestionaire.setUserId(u.getId());
			userQuestionaire.setCounselorId(counselorId);
			userQuestionaire.setQuestionaireId(questionnaireId);
			if (comment != null) {
				userQuestionaire.setComment(comment);
			}

			userQuestionaire.setRecommend(suggest);
			userQuestionaire.setType((short) 1);
			userQuestionaire.setUpdateDate(new Date());
			userQuestionaire.setCreateDate(new Date());
			userQuestionaire.setCounselingSessionId(counselingSessionId);
			userQuestionaire = userQuestionaireService.create(userQuestionaire);

			for (QASatisfactionEvaluation qa : qas) {
				TestResult testResult = new TestResult();
				testResult.setQuestionId(qa.getQuestionId());
				testResult.setPoint((float)qa.getPoint());
				testResult.setCreateDate(new Date());
				testResult.setUpdateDate(new Date());
				testResult.setUserQuestionaireId(userQuestionaire.getId());
				testResult = testResultService.create(testResult);
			}
			userQuestionaireService.updatePointByUserQuestionAire(userQuestionaire.getId());
			Counselor c = counselorService.findById(counselorId);
			Float avgPoint = userQuestionaireService.totalPointCounsolerId(counselorId);
			if(suggest>0){
				Integer likes = userQuestionaireService.totalRecommendBYCounselorId(counselorId);
				c.setLikes(likes);
			}
			c.setPoints(avgPoint);
			CounselingSession cSession = counselingSessionService.findById(counselingSessionId);
			cSession.setPoint(userQuestionaireService.findById(userQuestionaire.getId()).getPoint());
			cSession = counselingSessionService.update(cSession);
			c = counselorService.update(c);
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/mindCheck/questions", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> mindCheckQuestions(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			List<Question> questions = new ArrayList<>();
			List<Answer> answers = new ArrayList<>();
			List<QAMindCheck> checks = new ArrayList<>();
			if (httpRequest.getHeader("token") != null) {
				questions = questionService.listQuestionByIsShowQsn((short) 2);
				if (questions.size() > 0) {
					ret.put("questionnaireId", questions.get(0).getQuestionaireId());
					for (int i = 0; i < questions.size(); i++) {
						QAMindCheck qaMindCheck = new QAMindCheck();
						qaMindCheck.setQuestion(questions.get(i));
						answers = answerService.getAnswersByQuestionId(questions.get(i).getId());
						qaMindCheck.setAnswers(answers);
						checks.add(qaMindCheck);
					}
				}
			}

			ret.put("QAMindChecks", checks);
			ret.put("totalQuestions", questions.size());

			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/mindCheck/complete", method = { RequestMethod.POST,
			RequestMethod.GET }, produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> completeMindCheck(@RequestHeader(value = "token", required = false) String token,
			@RequestBody String json) {
		UserItem user = AuthorizationToken.convertToObject(token);
		try {
			User u = userService.findById(user.getId());
			HashMap<String, Object> ret = new HashMap<String, Object>();
			GsonBuilder builder = new GsonBuilder();
			builder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
				public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
						throws JsonParseException {
					return new Date(json.getAsJsonPrimitive().getAsLong());
				}
			});

			JsonParser parser2 = new JsonParser();
			JsonObject jsonObject = parser2.parse(json).getAsJsonObject();
			JsonArray jsonArray = jsonObject.getAsJsonArray("QAMindChecks");
			Gson gson = builder.create();
			List<QAMindcheckUser> qas = gson.fromJson(jsonArray.toString(), new TypeToken<List<QAMindcheckUser>>() {
			}.getType());

			org.json.simple.parser.JSONParser parser = new JSONParser();
			JSONObject jsonObj = (JSONObject) parser.parse(json);
			Integer counselorId = (Integer.valueOf(jsonObj.get("counselorId").toString()));
			Integer questionnaireId = (Integer.valueOf(jsonObj.get("questionnaireId").toString()));
			String osName = String.valueOf(jsonObj.get("osName"));
			UserQuestionaire userQuestionaire = new UserQuestionaire();
			userQuestionaire.setUserId(u.getId());
			userQuestionaire.setCounselorId(counselorId);
			userQuestionaire.setQuestionaireId(questionnaireId);
			userQuestionaire.setPoint((float) 0);
			userQuestionaire.setType((short) 2);
			userQuestionaire.setCreateDate(new Date());
			userQuestionaire.setOsName(osName);
			UserQuestionaire create = userQuestionaireService.create(userQuestionaire);

			float point = 0f;
			for (QAMindcheckUser qa : qas) {
				TestResult testResult = new TestResult();
				testResult.setQuestionId(qa.getQuestionId());
				Answer answer = answerService.findById(qa.getAnswerId());
				testResult.setPoint(answer.getPoint());
				testResult.setCreateDate(new Date());
				testResult.setUpdateDate(new Date());
				testResult.setAnswerId(qa.getAnswerId());
				testResult.setUserQuestionaireId(create.getId());
				testResult = testResultService.create(testResult);

				point = point + testResult.getPoint();
			}
			create.setRecommend((short) 0);
			create.setPoint((float) point);
			create.setUpdateDate(new Date());
			create = userQuestionaireService.update(create);
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/account/changePassword", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> changePassword(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				String oldPassBuild = EncryptionUtils.jwtBuild(String.valueOf(params.get("oldPass")));
				String newPassBuild = EncryptionUtils.jwtBuild(String.valueOf(params.get("newPass")));
				List<PasswordHistoryEntity> listPassWd = passwordHistoryService.findLastestByUserAndCreateDate(u.getId(), 3);
				List<String> listPass = new ArrayList<String>();
				for (PasswordHistoryEntity p : listPassWd) {
					listPass.add(p.getPassword());
				}
				
				if (!oldPassBuild.equals(u.getPassword())) {
					return FAIL_CHANGEPASS_OLDNOTMATCH(ret);
				} else {
					if (!listPass.contains(newPassBuild) ) {
						u.setPassword(newPassBuild);
						u = userService.update(u);
						PasswordHistory p = new PasswordHistory();
						p.setUserId(u.getId());
						p.setPassword(newPassBuild);
						p.setCreateDate(new Date());
						p.setUpdateDate(new Date());
						p = passwordHistoryService.create(p);
						return SUCCESS_CHANGEPASS(ret);
					} else {
						return FAIL_CHANGEPASS(ret);
					}
				}
			} else {
				return FAIL();
			}
			
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/account/memberWithdrawal", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> memberWithdrawal(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		HashMap<String, Object> ret = new HashMap<String, Object>();
		if (httpRequest.getHeader("token") != null) {
			String token = httpRequest.getHeader("token");
			UserItem user = AuthorizationToken.convertToObject(token);
			User u = userService.findById(user.getId());
			String passwordBuild = EncryptionUtils.jwtBuild(String.valueOf(params.get("password")));
			String reason = String.valueOf(params.get("withdrawalReason"));
			Short typeReason = Short.parseShort(String.valueOf(params.get("typeReason")));
			if (!passwordBuild.equals(u.getPassword())) {
				return FAIL_MEMBER_WITHDRAWAl_1(ret);
			} else {
				List<CounselingSession> counselingSessions = counselingSessionService.findEarliestCounselingTime(u.getId());
				if (counselingSessions.size() > 0) {
					return FAIL_MEMBER_WITHDRAWAl_2(ret);
				} else {
					//delete hello coin
					userService.updateCoinByUserId(u.getId(), u.getCoin(), ApplicationDefine.Payment_TypePaymentStatus.Payment.getCode() , ApplicationDefine.PaymentTypeUse.Manual_deduction.getCode(), null);
					//delete heart
					userService.updateHeartByUserId(u.getId(), u.getHeart(), ApplicationDefine.Payment_TypePaymentStatus.Payment.getCode() , ApplicationDefine.PaymentHeart_Status.WithdrawAccount.getCode(), null);
					//delete voucher
					voucherUserService.deleteVouchertByUserId(u.getId());
					u.setIsDelete(1);
					u.setStatusActive((short) 3);
					u.setWithdrawalReason(reason);
					u.setWithdrawalDate(new Date());
					u.setUpdateDate(new Date());
					u.setHeart(0);
					u.setVoucherNumber(0);
					u.setHeart(0);
					u.setCoin(0);
					u.setTypeWithdrawalReason(typeReason);
					u = userService.update(u);
					return SUCCESS_MEMBER_WITHDRAWAl(ret);
				}
			}
		}
		return ret;
	}

	@RequestMapping(value = "/psychologicalTest/processing", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> processPsychologicalTest(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				if (u != null) {
					List<PsychologicalTest> result = requestUserPsychologicalService.listRequestUserPsyByUserId(u.getId());
					ret.put("finalPsychologicalTest", result);
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/psychologicalTest/payment1", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> paymentPsychologicalTest(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				if (u != null) {
					Integer fee = (Integer.valueOf(params.get("fee").toString()));
					Integer countVoucher = voucherUserService.totalVoucherNoUsedByUserId(u.getId());
					if (fee == null) {
						fee = 0;
					}
					if (u.getCoin() >= fee) {
						ret.put("showPopup", 3);
					} else {
						ret.put("showPopup", 5);
					}
					ret.put("fee", fee);
					ret.put("currentCoin", u.getCoin());
					ret.put("currentVoucher", countVoucher);
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/psychologicalTest/testResult", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> testResultPsychological(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			if (httpRequest.getHeader("token") != null) {
				String token = httpRequest.getHeader("token");
				UserItem user = AuthorizationToken.convertToObject(token);
				User u = userService.findById(user.getId());
				List<PsychologicalTestResult> psychologicalTestResults = new ArrayList<>();
				if (u != null) {
					List<UserPsychologicalFileApi> list = userPsychologicalFileService.listByUserId(u.getId());
					List<UserPsychologicalFileApi> userPsychologicalFiles = new ArrayList<>();
					List<Integer> userPsychologicalFileIds = new ArrayList<>();
					
					if (list.size() > 0) {
						UserPsychologicalFileApi index_0 = list.get(0);
						PsychologicalTestResult p = new PsychologicalTestResult();
						p.setPsychologicalTestSettingId(index_0.getPsychologicalTestSettingId());
						p.setTestName(index_0.getTestName());
						userPsychologicalFileIds.add(list.get(0).getId());
						userPsychologicalFiles.add(index_0);
						p.setUserPsychologicalFiles(userPsychologicalFiles);
						psychologicalTestResults.add(p);
						userPsychologicalFileIds.add(index_0.getId());
						p.setUserPsychologicalFileIds(userPsychologicalFileIds);
						for (int i = 1; i < list.size(); i++) {
							UserPsychologicalFileApi index_i = list.get(i);
							if (index_0.getPsychologicalTestSettingId() == index_i.getPsychologicalTestSettingId()) {
								userPsychologicalFiles.add(index_i);
								userPsychologicalFileIds.add(index_i.getId());
								p.setUserPsychologicalFiles(userPsychologicalFiles);
							} else {
								index_0 = index_i;
								PsychologicalTestResult p_i = new PsychologicalTestResult();
								p_i.setPsychologicalTestSettingId(index_0.getPsychologicalTestSettingId());
								p_i.setTestName(index_0.getTestName());
								p = p_i;
								List<UserPsychologicalFileApi> userPsychologicalFiles_i = new ArrayList<>();
								userPsychologicalFiles_i.add(index_0);
								userPsychologicalFiles = userPsychologicalFiles_i;
								p.setUserPsychologicalFiles(userPsychologicalFiles);

								List<Integer> userPsychologicalFileIds_i = new ArrayList<>();
								userPsychologicalFileIds_i.add(index_0.getId());
								userPsychologicalFileIds = userPsychologicalFileIds_i;
								p.setUserPsychologicalFileIds(userPsychologicalFileIds);
								psychologicalTestResults.add(p);
							}
						}
					}
					
					for (PsychologicalTestResult psychologicalTestResult : psychologicalTestResults) {
						int count = 0;
						for (Integer e : psychologicalTestResult.getUserPsychologicalFileIds()) {
							if (e == null) {
								count = count + 1;
							}
						}
						
						if (count == psychologicalTestResult.getUserPsychologicalFileIds().size()) {
							psychologicalTestResult.setStatusDisable(1);
						} else {
							psychologicalTestResult.setStatusDisable(0);
						}
						
						int index = psychologicalTestResult.getUserPsychologicalFiles().size() - 1;
						
						for (int ii = index; ii >= 0; ii--) {
							if (psychologicalTestResult.getUserPsychologicalFiles().get(ii).getId() == null) {
								psychologicalTestResult.getUserPsychologicalFiles().remove(ii);
							}
						}
					}
					
					
					
					ret.put("statusResult", 1);
					
				} else {
					ret.put("statusResult", 0);
				}
				ret.put("psychologicalTestResults", psychologicalTestResults);
			}
			
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/selfDiagnosis/questions", method = RequestMethod.POST)
	@ResponseBody
	public HashMap<String, Object> getSelfDiagnosisQuestions(@RequestParam Map<String, Object> params,HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			List<SelfDiagnosisAnswer> selfDiagnosisAnswer = new ArrayList<>();
			List<SelfDiagnosisAnswer> selfDiagnosisAnswerCopy = new ArrayList<>();
			List<SelfDiagnosis> selfDiagnosis = new ArrayList<>();
			Integer typeSelfDia = Integer.valueOf(params.get("typeSelfDiagnosis").toString());
			List<Question> questions = questionService.listQuestionStressSelfDiagnosisByIsShowQsn((short) 3, typeSelfDia);
			selfDiagnosisAnswer = selfDiagnosisAnswerService.listBySelfDiagnosisField(typeSelfDia);
			if (httpRequest.getHeader("token") != null) {
				if (typeSelfDia == 2) {
					selfDiagnosisAnswerCopy = selfDiagnosisAnswer;
					for (int j = 0; j < selfDiagnosisAnswer.size(); j++) {
						if (selfDiagnosisAnswerCopy.get(j).getPoint() == 3) {
							selfDiagnosisAnswer.get(j).setPoint(0);
						} else if (selfDiagnosisAnswer.get(j).getPoint() == 2) {
							selfDiagnosisAnswerCopy.get(j).setPoint(1);
						} else if (selfDiagnosisAnswer.get(j).getPoint() == 1) {
							selfDiagnosisAnswerCopy.get(j).setPoint(2);
						} else {
							selfDiagnosisAnswerCopy.get(j).setPoint(3);
						}
					}
					
					if (questions.size() > 0) {
						ret.put("questionnaireId", questions.get(0).getQuestionaireId());
						for (int i = 0; i < questions.size(); i++) {
							SelfDiagnosis diagnosis = new SelfDiagnosis();
							diagnosis.setQuestion(questions.get(i));
							selfDiagnosisAnswer = selfDiagnosisAnswerService.listBySelfDiagnosisField(2);
							if (questions.get(i).getOrderNumber() == 5 || questions.get(i).getOrderNumber() == 10 || questions.get(i).getOrderNumber() == 15) {
								diagnosis.setSelfDiagnosisAnswers(selfDiagnosisAnswerCopy);
							} else {
								diagnosis.setSelfDiagnosisAnswers(selfDiagnosisAnswer);
							}
							
							selfDiagnosis.add(diagnosis);
						}
					}
				} else {
					
					if (questions.size() > 0) {
						ret.put("questionnaireId", questions.get(0).getQuestionaireId());
						for (int i = 0; i < questions.size(); i++) {
							SelfDiagnosis diagnosis = new SelfDiagnosis();
							diagnosis.setQuestion(questions.get(i));
							diagnosis.setSelfDiagnosisAnswers(selfDiagnosisAnswer);
							selfDiagnosis.add(diagnosis);
						}
					}
				}
			}
			ret.put("typeSelfDiagnosis", typeSelfDia);
			ret.put("QASelfDiagnosis", selfDiagnosis);
			ret.put("totalQuestions", questions.size());

			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}
	
	@RequestMapping(value = "/selfDiagnosis/complete", method = { RequestMethod.POST,
			RequestMethod.GET }, produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> completeSelfDiagnosis(@RequestHeader(value = "token", required = false) String token, @RequestBody String json) {
		UserItem user = AuthorizationToken.convertToObject(token);
		UserQuestionaire userQuestionaire = new UserQuestionaire();
		List<Integer> testResultIds = new ArrayList<>();
		try {
			User u = userService.findById(user.getId());
			HashMap<String, Object> ret = new HashMap<String, Object>();
			GsonBuilder builder = new GsonBuilder();
			builder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
				public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
						throws JsonParseException {
					return new Date(json.getAsJsonPrimitive().getAsLong());
				}
			});
			
			JsonParser parser2 = new JsonParser();
			JsonObject jsonObject = parser2.parse(json).getAsJsonObject();
			JsonArray jsonArray = jsonObject.getAsJsonArray("QASelfDiagnosis");
			Gson gson = builder.create();
			List<QASelfDiagnosis> qas = gson.fromJson(jsonArray.toString(), new TypeToken<List<QASelfDiagnosis>>() {
			}.getType());

			org.json.simple.parser.JSONParser parser = new JSONParser();
			JSONObject jsonObj = (JSONObject) parser.parse(json);
			Integer questionnaireId = (Integer.valueOf(jsonObj.get("questionnaireId").toString()));
			Integer typeSelfDiagnosis = (Integer.valueOf(jsonObj.get("typeSelfDiagnosis").toString()));
			
			userQuestionaire.setUserId(u.getId());
			userQuestionaire.setQuestionaireId(questionnaireId);
			userQuestionaire.setPoint((float) 0);
			userQuestionaire.setType((short) 3);
			userQuestionaire.setUpdateDate(new Date());
			userQuestionaire.setCreateDate(new Date());
			userQuestionaire.setRecommend((short) 0);
			userQuestionaire = userQuestionaireService.create(userQuestionaire);
			
			

			float point = 0;

			int countQuestion = 0;
			for (QASelfDiagnosis qa : qas) {
				TestResult testResult = new TestResult();
				testResult.setQuestionId(qa.getQuestionId());
				testResult.setSelfDiagnosisAnswerId(qa.getSelfDiagnosisAnswerId());
				testResult.setPoint(qa.getPoint());
				
				testResult.setCreateDate(new Date());
				testResult.setUpdateDate(new Date());

				testResult.setUserQuestionaireId(userQuestionaire.getId());
				testResult = testResultService.create(testResult);
				point = point + testResult.getPoint();
				countQuestion = countQuestion + 1;
				testResultIds.add(testResult.getId());
			}
			
			String result = "";
			Short typeIcon = null ;
			if (typeSelfDiagnosis == 1) {
				userQuestionaire.setPoint((float) (Math.round(((float)point / (float)countQuestion) * 10.0) / 10.0));
			} else {
				userQuestionaire.setPoint((float) point);
			}
			
			List<SelfDiagnosisResults> liSelfDiagnosisResults = selfDiagnosisResultsService.listSelfDiagnosisResultsByPoint(questionnaireId);
			Float pointt = userQuestionaire.getPoint();
			for (SelfDiagnosisResults s : liSelfDiagnosisResults) {
				if ((pointt >= s.getFromPoint()) && (pointt <= s.getToPoint())) {
					userQuestionaire.setSelfDiagnosisResultsId(s.getId());
					result = s.getContentResult();
					typeIcon = s.getTypeIcon();
				}
			}
			userQuestionaire = userQuestionaireService.update(userQuestionaire);

			ret.put("stressSelfDiagnosisResult", result);
			ret.put("questionaire_id", questionnaireId);
			ret.put("userName", u.getFullname());
			ret.put("typeIcon", typeIcon);

			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			if (userQuestionaire != null) {
				userQuestionaireService.delete(userQuestionaire.getId());
			}
			
			for (Integer integer : testResultIds) {
				testResultService.delete(integer);
			}
			
			return FAIL("HAVE ERROR: " + e);
		}
	}
	

	@RequestMapping(value = "/selfDiagnosis/stress/latestResult", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> getLatestResultOfStress(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				LatestSelfDiagnosisResult result = userQuestionaireService.findLatestResult(user.getId(), 3);
				if (result == null) {
					ret.put("statusData", 0);
					ret.put("userName", null);
					ret.put("stressSelfDiagnosisResult", null);
					ret.put("questionaire_id", null);
					ret.put("typeIcon", null);
				} else {
					ret.put("statusData", 1);
					ret.put("userName", result.getUserName());
					ret.put("stressSelfDiagnosisResult", result.getContentResult());
					ret.put("questionaire_id", result.getQuestionaireId());
					ret.put("typeIcon", result.getTypeIcon());
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/selfDiagnosis/anxietyDisorders/latestResult", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> getLatestResultOfAnxietydisorders(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				LatestSelfDiagnosisResult result = userQuestionaireService.findLatestResult(user.getId(), 5);
				if (result == null) {
					ret.put("statusData", 0);
					ret.put("userName", null);
					ret.put("stressSelfDiagnosisResult", null);
					ret.put("questionaire_id", null);
					ret.put("typeIcon", null);
				} else {
					ret.put("statusData", 1);
					ret.put("userName", result.getUserName());
					ret.put("stressSelfDiagnosisResult", result.getContentResult());
					ret.put("questionaire_id", result.getQuestionaireId());
					ret.put("typeIcon", result.getTypeIcon());
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/selfDiagnosis/depression/latestResult", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> getLatestResultOfDepression(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				LatestSelfDiagnosisResult result = userQuestionaireService.findLatestResult(user.getId(), 4);
				if (result == null) {
					ret.put("statusData", 0);
					ret.put("userName", null);
					ret.put("stressSelfDiagnosisResult", null);
					ret.put("questionaire_id", null);
					ret.put("typeIcon", null);
				} else {
					ret.put("statusData", 1);
					ret.put("userName", result.getUserName());
					ret.put("stressSelfDiagnosisResult", result.getContentResult());
					ret.put("questionaire_id", result.getQuestionaireId());
					ret.put("typeIcon", result.getTypeIcon());
				}
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	/* 0:off - 1:on */
	@RequestMapping(value = "/notification/setting", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> settingNotifi(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				Short reservationNotification = Short.valueOf(params.get("reservationNotification").toString());
				Short messageNotification = Short.valueOf(params.get("messageNotification").toString());
				Short eventNoticeNotification = Short.valueOf(params.get("eventNoticeNotification").toString());
				Short iniquiryNotification = Short.valueOf(params.get("iniquiryNotification").toString());

				User uSetting = userService.findById(user.getId());
				
				uSetting.setReservationNotification(reservationNotification);
				uSetting.setMessageNotification(messageNotification);
				uSetting.setEventNoticeNotification(eventNoticeNotification);
				uSetting.setIniquiryNotification(iniquiryNotification);
				uSetting.setUpdateDate(new Date());
				User update = userService.update(uSetting);
				ret.put("reservationNotification", update.getReservationNotification());
				ret.put("messageNotification", update.getMessageNotification());
				ret.put("eventNoticeNotification", update.getEventNoticeNotification());
				ret.put("iniquiryNotification", update.getIniquiryNotification());
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/notification/setting", method = RequestMethod.GET)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> settingNotifiGET(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				User uSetting = userService.findById(user.getId());
				ret.put("reservationNotification", uSetting.getReservationNotification());
				ret.put("messageNotification", uSetting.getMessageNotification());
				ret.put("eventNoticeNotification", uSetting.getEventNoticeNotification());
				ret.put("iniquiryNotification", uSetting.getIniquiryNotification());
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}

	@RequestMapping(value = "/myhello/exchangeVoucher", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> exchangeVoucher(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
				Integer voucherId = Integer.valueOf(params.get("voucherId").toString());
				Voucher voucher = voucherService.findById(voucherId);
				VoucherUser voucherUser = new VoucherUser();
				voucherUser.setUserId(user.getId());
				voucherUser.setVoucherId(voucherId);
				voucherUser.setFromDate(new Date());
				Calendar c = Calendar.getInstance();
				c.setTime(voucherUser.getFromDate());
				c.add(Calendar.DATE, voucher.getDateNumber());
				voucherUser.setToDate(c.getTime());
				voucherUser.setStatusUse((short) 0);
				voucherUser.setCreateDate(new Date());
				voucherUser.setUpdateDate(new Date());
				voucherUser.setReason("하트 교환");
				voucherUser = voucherUserService.create(voucherUser);
				userService.updateHeartByUserId(user.getId(), voucher.getHeartNumber(), ApplicationDefine.Payment_TypePaymentStatus.Payment.getCode(), ApplicationDefine.PaymentHeart_Status.Exchange_Voucher.getCode(),"");
				userService.updateVoucherNumberByUserId(user.getId());
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}
	
	@RequestMapping(value = "/share/complete", method = RequestMethod.POST)
	@ResponseBody
	@ResponseStatus(HttpStatus.OK)
	public HashMap<String, Object> share(@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
		try {
			HashMap<String, Object> ret = new HashMap<String, Object>();
			String token = httpRequest.getHeader("token");
			String type = String.valueOf(params.get("type").toString());
			String osName = String.valueOf(params.get("osName"));
			if (token != null) {
				UserItem user = AuthorizationToken.convertToObject(token);
//				Date now = new Date();
//				Integer count =paymentHistoryService.counShareBy_TypeShare(user.getId(), ApplicationDefine.RechargeHeart_Status.AppShare.getCode(), type, now);
//				if( count >0){
//					User u = userService.findById(user.getId());
//					ret.put("heart", u.getHeart());
//					ret.put("success", 0);
//				}else{
//					ret.put("success", 1);
//					userService.updateHeartByUserId(user.getId(), ApplicationDefine.Heart_Number.Shared.getCode(), ApplicationDefine.Payment_TypePaymentStatus.Recharge.getCode(), ApplicationDefine.RechargeHeart_Status.AppShare.getCode(),type);
//					User u = userService.findById(user.getId());
//					ret.put("heart", u.getHeart());
//				}
				ShareHistory s =  new ShareHistory();
				s.setOsName(osName);
				s.setCreateDate(new Date());
				s.setType(type);
				s.setUserId(user.getId());
				shareHistoryService.create(s);
			}
			return SUCCESS(ret);
		} catch (Exception e) {
			e.printStackTrace();
			return FAIL("HAVE ERROR: " + e);
		}
	}
	
	@RequestMapping(value = "/resultCode", method = RequestMethod.POST, produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseStatus(HttpStatus.OK)
	@ResponseBody
	public HashMap<String, Object> resultCode(
			@RequestParam Map<String, Object> params,
			HttpServletRequest httpRequest) {
			try {
				Date currentDate = new Date();
				Integer counselingId =  Integer.valueOf(params.get("counselingSessionId").toString());
				Short resultCode =  Short.valueOf(params.get("resultCode").toString());
				CounselingSession c = counselingSessionService.findById(counselingId); 
				c.setResultCode(resultCode);
				if(!c.getStatus().equals(ApplicationDefine.CounselingSessionStatus.COUNSELD.getCode())){
					c.setEndTime(currentDate);
			        c.setExitCounselorTime(currentDate);
			        c.setExitUserTime(currentDate);
			        c.setStatus(ApplicationDefine.CounselingSessionStatus.COUNSELD.getCode());
				}
				counselingSessionService.update(c);
				return SUCCESS();
			} catch (Exception e) {
				e.printStackTrace();
				return FAIL(e.getMessage());
			}
	}
}
